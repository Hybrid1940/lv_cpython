# This module overrides the python import system so that we are able to
# manipulate hoiw things are accessed in LVGL. so a user  should be able to do
# the following

import os
import sys

try:
    import _lib_lvgl
except ImportError:
    base_path = os.path.dirname(__file__)
    build_path = os.path.join(base_path, 'build')

    sys.path.insert(0, build_path)

    import _lib_lvgl


class _Function(object):

    def __init__(self, func):
        self.__func = func

    def __call__(self, *args):
        args = list(args)

        last_arg = None

        new_args = []
        for i, arg in enumerate(args):
            if last_arg is not None and i == len(args) - 1:
                new_args.append(last_arg)
                break

            if isinstance(arg, _CallbackWrapper):
                if i == 0:
                    raise RuntimeError(
                        'callback functions cannot be the '
                        'first parameter in a function call'
                    )
                if isinstance(args[0], _StructWrapper):
                    if not args[0].has_user_data:
                        raise RuntimeError(
                            'first parameter has no user_data field'
                        )

                    cb_store = args[0].cb_store

                    if cb_store is None:
                        cb_store = _CBStore()
                        cb_store_handle = _lib_lvgl.ffi.new_handle(cb_store)
                    else:
                        cb_store_handle = cb_store[1]
                        cb_store = cb_store[0]

                    args[0].cb_store = (cb_store, cb_store_handle)
                    cb_store[arg.ctype[3:]] = arg

                    last_arg = cb_store_handle

                else:
                    raise ValueError(
                        'the first parameter must be a structure and it must '
                        'have a field named "user_data" when passing a '
                        'callback to a function'
                    )

                new_args.append(arg._obj)

            else:
                new_args.append(_get_c_obj(arg))

        self.__dict__['__c_args__'] = new_args
        self.__dict__['__py_args__'] = args

        res = self.__func(*new_args)
        return _get_py_object(res)


def _get_py_object(c_obj):

    if c_obj == _lib_lvgl.ffi.NULL:
        return None

    if isinstance(c_obj, (int, float)):
        return c_obj

    if isinstance(c_obj, bytes):
        return c_obj.decode('utf-8')

    try:
        cdata = str(_lib_lvgl.ffi.typeof(c_obj)).replace("'", '')
    except:
        return c_obj

    c_type = ''

    for itm in cdata.split(' '):
        if '*' in itm:
            break

        c_type = itm

    c_type = c_type.replace('>', '').strip()

    if '[' in c_type and ']' in c_type:
        size = c_type.split('[', 1)[-1].split(']', 1)[0]
        if size.isdigit():
            size = int(size)
        else:
            size = None

        cls = type(c_type, (_ArrayWrapper,))
        return cls(c_obj, size)

    num_star = cdata.count('*')

    if num_star > 1:

        cls = type(c_type + ' ' + ('*' * num_star), (_ArrayWrapper,))
        return cls(c_obj)

    cls = type(c_type, (_StructWrapper,), {'_obj': c_obj})
    return cls()


def _get_c_obj(py_obj):
    if isinstance(py_obj, _StructWrapper):
        return py_obj._obj

    if isinstance(py_obj, _ArrayWrapper):
        return py_obj._obj

    if isinstance(py_obj, _CallbackWrapper):
        return py_obj._obj

    if isinstance(py_obj, (int, float)):
        return py_obj

    if isinstance(py_obj, str):
        return py_obj.encode('utf-8')

    if isinstance(py_obj, (list, tuple)):
        array = []
        c_type = None

        for item in py_obj:
            c_obj = _get_c_obj(item)
            if isinstance(item, _StructWrapper) and c_type is None:
                cdata = str(_lib_lvgl.ffi.typeof(c_obj)).replace("'", '')
                c_type = ''

                for itm in cdata.split(' '):
                    if '*' in itm:
                        break

                    c_type = itm

                c_type = c_type.replace('>', '').strip()

            array.append(c_obj)

        if c_type is not None:
            array = _lib_lvgl.ffi.new(c_type + '[{0}]'.format(len(array), array))

        return array

    return py_obj


class _CBStore(dict):
    pass


class _StructWrapper(object):
    _initilizer = ''
    _obj = None

    def __dir__(self):
        return dir(self._obj)

    def __init__(self, **kwargs):
        if self._obj is None:
            for k, v in list(kwargs.items())[:]:
                val = _get_c_obj(v)

                self.__dict__['__py_' + k + '__'] = v
                self.__dict__['__c_' + k + '__'] = val

                kwargs[k] = val

            if kwargs:
                self.__dict__['_obj'] = _lib_lvgl.ffi.new(self._initilizer, kwargs)
            else:
                self.__dict__['_obj'] = _lib_lvgl.ffi.new(self._initilizer)
        else:
            self.__dict__['_obj'] = self._obj

    def __getattr__(self, item):
        if item in self.__dict__:
            return self.__dict__[item]

        if hasattr(_StructWrapper, item):
            obj = getattr(_StructWrapper, item)
            if isinstance(obj, property):
                return obj.fget(self)

        try:
            res = getattr(self._obj, item)
        except AttributeError:
            raise AttributeError(item)

        obj = _get_py_object(res)

        self.__dict__['__py_' + item + '__'] = obj

        return obj

    @property
    def cb_store(self):
        return self.__dict__.get('__cb_store__', None)

    @cb_store.setter
    def cb_store(self, value):
        if not isinstance(value, tuple) or not isinstance(value[0], _CBStore):
            raise ValueError('incorrect data type')

        self.__dict__['__cb_store__'] = value

    @property
    def has_user_data(self):
        try:
            _ = self.user_data
            return True
        except AttributeError:
            return False

    def __setattr__(self, key, value):
        if hasattr(_StructWrapper, key):
            obj = getattr(_StructWrapper, key)
            if isinstance(obj, property):
                obj.fset(self, value)
                return

        try:
            obj = getattr(self._obj, key)
            cdata = str(_lib_lvgl.ffi.typeof(obj)).replace("'", '')

            for item in ('_cb_t', '_f_t'):
                if item in cdata:
                    if not self.has_user_data:
                        raise RuntimeError(
                            'no user_data field avaailable for structure "{0}"'.format(
                                self.__name__
                            )
                        )

                    type_name = ''

                    for item in cdata.split(' '):
                        if '*' in item:
                            break

                        type_name = item

                    type_name = type_name.lstrip('lv_')

                    if not isinstance(value, _CallbackWrapper):
                        glob = globals()

                        if type_name not in glob:
                            raise RuntimeError('Sanity Check')

                        value = glob[type_name](value)

                    cb_store = self.cb_store

                    if cb_store is None:
                        cb_store = _CBStore()
                        cb_store_handle = _lib_lvgl.ffi.new_handle(cb_store)
                        self.user_data = cb_store_handle
                        self.cb_store = (cb_store, cb_store_handle)
                    else:
                        cb_store = cb_store[0]

                    cb_store[type_name] = value
                    setattr(self._obj, key, value.c_func)

                    self.__dict__['__c_' + key + '__'] = value
        except:
            c_obj = _get_c_obj(value)

            self.__dict__['__py_' + key + '__'] = value
            setattr(self._obj, key, c_obj)


class _StructFactory(object):

    def __init__(self, initilizer):
        self.name = ''

        for item in initilizer.split(' '):
            if '*' in item:
                break
            self.name = item

        self.__initilizer = initilizer

    def __call__(self, **kwargs):
        cls = type(
            self.name,
            (_StructWrapper,),
            {'_initilizer': self.__initilizer}
        )
        return cls(**kwargs)


class _ArrayWrapper(object):

    def __init__(self, obj, size=None):
        self._obj = obj
        self._size = size
        self.__array = None

    def __len__(self):
        if self._size is None:
            count = 0

            while True:
                item = self._obj[count]
                if item == _lib_lvgl.ffi.NULL:
                    break

                count += 1
            self._size = count

        return self._size

    def __iter__(self):
        if self.__array is None:
            array = []

            if self._size is None:
                _ = len(self)

            for i in range(self._size):
                item = self._obj[i]
                array.append(_get_py_object(item))

            self.__array = array

        return iter(self.__array)

    def __getitem__(self, item):
        return list(self)[item]

    def __setitem__(self, key, value):
        array = list(self)

        if isinstance(key, slice):
            start = key.start
            stop = key.stop

            for i in range(start, stop):
                array[i] = value[i - start]
                self._obj[i] = _get_c_obj(value[i - start])
        else:
            array[key] = value
            self._obj[key] = _get_c_obj(value)

        self.__array = array


class _CallbackWrapper(object):

    def __init__(self, ctype, func=None):
        self.ctype = ctype
        self._obj = getattr(_lib_lvgl.lib, 'py_' + ctype)
        self.py_obj = _lib_lvgl.ffi.new_handle(self)
        self.func = func

    @staticmethod
    def _callback_func(func_wrapper, *args):
        new_args = []

        for arg in args:
            if isinstance(arg, (int, float)):
                new_args.append(arg)
                continue

            if isinstance(arg, bytes):
                new_args.append(arg.decode('utf-8'))
                continue

            try:
                cdata = str(_lib_lvgl.ffi.typeof(arg)).replace("'", '')
            except:
                new_args.append(arg)
                continue
            else:
                num_star = cdata.count('*')
                if num_star > 1:
                    name = ''

                    for itm in cdata.split(' '):
                        if '*' in itm:
                            break

                        name = itm

                    name += ' ' + ('*' * num_star)

                    cls = type(name, (_ArrayWrapper,))
                    array = cls(arg)

                    new_args.append(array)
                    continue

                name = ''

                for item in cdata.split(' '):
                    if '*' in item:
                        break

                    name = item

                cls = type(name, (_StructWrapper,), {'_obj': arg})
                obj = cls()
                new_args.append(obj)

        return func_wrapper.func(*new_args)

~!~!CALLBACKS!~!~


class _lvgl(object):

    def __init__(self):
        mod = sys.modules[__name__]
        self.__name__ = mod.__name__
        self.__doc__ = mod.__doc__
        self.__package__ = mod.__package__
        self.__loader__ = mod.__loader__
        self.__spec__ = mod.__spec__
        self.__file__ = mod.__file__
        self.__original_mod__ = mod

        for key, value in mod.__dict__.items():
            if key.startswith('_'):
                continue

            if isinstance(value, _CallbackWrapper):
                object.__setattr__(self, key, value)

        sys.modules[__name__] = self

    def __getattr__(self, item):
        if item in self.__dict__:
            return self.__dict__[item]

        if item == 'NULL':
            return _lib_lvgl.ffi.NULL

        elif item.startswith('_'):
            if item.isupper():
                if hasattr(_lib_lvgl.lib, '_LV_' + item):
                    res = getattr(_lib_lvgl.lib, '_LV_' + item)
                else:
                    raise AttributeError(item)

            elif hasattr(_lib_lvgl.lib, '_lv_' + item):
                res = _Function(getattr(_lib_lvgl.lib, '_lv_' + item))

            elif hasattr(_lib_lvgl.ffi, item):
                return getattr(_lib_lvgl.ffi, item)

            else:
                try:
                    _lib_lvgl.ffi.new('_lv_' + item + ' *')
                except:
                    raise AttributeError(item)
                else:
                    res = _StructFactory('_lv_' + item + ' *')

        elif item.isupper():
            if hasattr(_lib_lvgl.lib, 'LV_' + item):
                res = getattr(_lib_lvgl.lib, 'LV_' + item)
            elif hasattr(_lib_lvgl.lib, 'ENUM_LV_' + item):
                res = getattr(_lib_lvgl.lib, 'ENUM_LV_' + item)
            else:
                raise AttributeError(item)

        elif hasattr(_lib_lvgl.lib, 'lv_' + item):
            res = _Function(getattr(_lib_lvgl.lib, 'lv_' + item))

        elif hasattr(_lib_lvgl.ffi, item):
            return getattr(_lib_lvgl.ffi, item)

        else:
            try:
                _lib_lvgl.ffi.new('lv_' + item + ' *')
            except:
                raise AttributeError(item)
            else:
                res = _StructFactory('lv_' + item + ' *')

        object.__setattr__(self, item, res)

        return res


__lvgl = _lvgl()
